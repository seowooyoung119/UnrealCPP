# 🔧 리팩토링

## 📋 목차
1. [코드 세분화 vs. 코드 통합](#1-코드-세분화-vs-코드-통합)
2. [객체 세분화 vs. 객체 통합](#2-객체-세분화-vs-객체-통합)
3. [간접 접근 vs. 직접 접근](#3-간접-접근-vs-직접-접근)
4. [조건문 vs. 다형성](#4-조건문-vs-다형성)
5. [상속 vs. 위임](#5-상속-vs-위임)

---

## 1. 코드 세분화 vs. 코드 통합

### 🎯 코드 세분화 (Extract)

| 기법 | 설명 | Before | After |
|------|------|---------|--------|
| **함수 추출하기** | 복잡한 로직을 별도 함수로 분리 | `if (health < 0) { /* 복잡한 죽음 처리 */ }` | `if (health < 0) { HandleDeath(); }` |
| **변수 추출하기** | 복잡한 표현식을 의미있는 변수로 추출 | `baseDamage * (1 + critChance * 2.0f)` | `critMultiplier = 1 + critChance * 2.0f;` |
| **클래스 추출하기** | 관련 필드들을 별도 클래스로 분리 | `Player { Name, Address, Email }` | `Player { Name, ContactInfo }` |

### 🎯 코드 통합 (Inline)

| 기법 | 설명 | Before | After |
|------|------|---------|--------|
| **함수 인라인하기** | 불필요한 함수를 제거하고 코드 직접 삽입 | `if (IsDead()) { HandleDeath(); }` | `if (health <= 0) { HandleDeath(); }` |
| **변수 인라인하기** | 불필요한 중간 변수 제거 | `temp = price - discount; final = temp + shipping;` | `final = (price - discount) + shipping;` |
| **클래스 인라인하기** | 단순한 클래스를 상위 클래스로 통합 | `Enemy { Position pos; }` | `Enemy { float X, Y; }` |

### 📊 결정 기준

| 🔄 **세분화가 적합한 상황** | 🔄 **통합이 적합한 상황** |
|---------------------------|-------------------------|
| ✅ 코드가 복잡하고 이해하기 어려울 때 | ✅ 추상화가 오히려 복잡성을 증가시킬 때 |
| ✅ 재사용 가능성이 있을 때 | ✅ 간단한 로직이 불필요하게 분리되어 있을 때 |
| ✅ 변경 가능성이 높은 부분 | ✅ 사용되는 곳이 한 곳뿐인 단순한 코드 |
| ✅ '무엇'과 '어떻게'를 분리할 필요가 있을 때 | ✅ 함수/변수 이름이 실제 로직에 가치를 더하지 않을 때 |

---

## 2. 객체 세분화 vs. 객체 통합

### 🎯 객체 세분화

| 기법 | 목적 | 예시 |
|------|------|------|
| **매개변수 객체 만들기** | 여러 매개변수를 객체로 묶기 | `CreateQuest(title, desc, gold, exp)` → `CreateQuest(questData)` |
| **단계 쪼개기** | 복잡한 처리를 독립적인 단계로 분리 | `LoadAndDisplay()` → `LoadItem()` + `DisplayItem()` |
| **반복문 쪼개기** | 하나의 반복문을 여러 목적별로 분리 | 한 루프에서 계산+렌더링 → 계산 루프 + 렌더링 루프 |

### 🎯 객체 통합

| 기법 | 목적 | 예시 |
|------|------|------|
| **여러 함수를 클래스로 묶기** | 관련 함수들을 하나의 클래스로 통합 | `StartTimer()`, `StopTimer()`, `GetElapsed()` → `Timer` 클래스 |
| **변환 함수로 묶기** | 여러 계산 함수를 하나의 변환 함수로 통합 | `GetBase()` + `GetCrit()` → `CalculateTotal()` |

### 📊 결정 기준

| 🔄 **세분화가 적합한 상황** | 🔄 **통합이 적합한 상황** |
|---------------------------|-------------------------|
| ✅ 책임이 명확히 분리될 때 | ✅ 강한 응집력이 필요할 때 |
| ✅ 다른 용도로 재사용 가능할 때 | ✅ 관련 데이터와 동작이 함께 있는 것이 자연스러울 때 |
| ✅ 독립적으로 테스트하고 싶을 때 | ✅ 공유 상태에 대한 관리가 필요할 때 |
| ✅ 복잡한 단계를 나누어 명확히 하고 싶을 때 | ✅ 여러 작은 함수들이 항상 함께 사용될 때 |

---

## 3. 간접 접근 vs. 직접 접근

### 🎯 간접 접근 (Encapsulate)

| 기법 | 목적 | 핵심 아이디어 |
|------|------|-------------|
| **변수 캡슐화하기** | 직접 접근 금지, 검증 로직 추가 | `player->health = 100` → `player->SetHealth(100)` |
| **레코드 캡슐화하기** | 구조체를 클래스로 변환 | `PlayerData.Level = 5` → `player.SetLevel(5)` |
| **컬렉션 캡슐화하기** | 컬렉션 접근 제어 | `Inventory.Add()` → `inventorySystem.AddItem()` |

### 🎯 직접 접근 (Remove Indirection)

| 기법 | 목적 | 핵심 아이디어 |
|------|------|-------------|
| **중개자 제거하기** | 불필요한 위임 체인 제거 | `manager->GetPlayer()->GetName()` → `manager->GetPlayerName()` |
| **위임 숨기기** | 복잡한 접근 경로 단순화 | `player.contact.address.zip` → `player.GetZipCode()` |

### 📊 결정 기준

| 🔒 **간접 접근이 적합한 상황** | 🚀 **직접 접근이 적합한 상황** |
|------------------------------|--------------------------------|
| ✅ 데이터 검증이나 부가 처리가 필요할 때 | ✅ 과도한 래퍼가 복잡성만 증가시킬 때 |
| ✅ 변경 추적이 필요할 때 | ✅ 성능이 중요한 핫스팟일 때 |
| ✅ 향후 구현 변경 가능성이 있을 때 | ✅ 단순한 데이터 구조에서 |
| ✅ 중복된 접근 로직이 여러 곳에 있을 때 | ✅ 위임 체인이 너무 길어질 때 |

---

## 4. 조건문 vs. 다형성

### 🎯 조건문 개선

| 기법 | 목적 | 예시 |
|------|------|------|
| **조건문 분해하기** | 복잡한 조건을 의미있는 함수로 추출 | `if (hasKey && isAlive && !stunned)` → `if (CanOpenDoor())` |
| **조건식 통합하기** | 여러 조건을 하나로 통합 | `if (dead) return; if (disconnected) return;` → `if (dead \|\| disconnected)` |

### 🎯 다형성 도입

| 기법 | 목적 | 핵심 아이디어 |
|------|------|-------------|
| **조건부 로직을 다형성으로 바꾸기** | 타입별 분기를 다형성으로 대체 | `if (type == "Orc")` → `enemy->GetDamage()` |
| **특이 케이스 추가하기** | null 체크를 null 객체로 대체 | `if (player) show(name) else show("Guest")` → `player->GetName()` |

### 📊 결정 기준

| 🔀 **조건문이 적합한 상황** | 🎭 **다형성이 적합한 상황** |
|---------------------------|---------------------------|
| ✅ 단순한 분기 로직일 때 | ✅ 타입별 동작 차이가 뚜렷할 때 |
| ✅ 일회성이거나 지역적인 결정일 때 | ✅ 타입 추가가 자주 발생할 때 |
| ✅ 성능이 매우 중요한 곳일 때 | ✅ 타입별 코드가 반복적으로 나타날 때 |
| ✅ 타입 배열이 고정적일 때 | ✅ 동작이 확장될 가능성이 높을 때 |

---

## 5. 상속 vs. 위임

### 🎯 상속 활용

| 기법 | 목적 | 예시 |
|------|------|------|
| **메서드 올리기** | 중복 메서드를 상위 클래스로 이동 | `Orc::Die()`, `Goblin::Die()` → `Enemy::Die()` |
| **필드 올리기** | 공통 필드를 상위 클래스로 이동 | `Orc::Health`, `Goblin::Health` → `Enemy::Health` |
| **슈퍼클래스 추출하기** | 공통 부분을 상위 클래스로 추출 | `Player`, `NPC` → `ActorBase` |

### 🎯 위임 활용

| 기법 | 목적 | 핵심 아이디어 |
|------|------|-------------|
| **서브클래스를 위임으로 바꾸기** | 상속을 컴포지션으로 대체 | `class OrcEnemy : Enemy` → `class Enemy { SoundBehavior }` |
| **슈퍼클래스를 위임으로 바꾸기** | 상속 관계를 위임 관계로 변경 | `ScoreWidget : UIWidget` → `ScoreWidget { WidgetRenderer }` |

### 📊 결정 기준

| 🏗️ **상속이 적합한 상황** | 🤝 **위임이 적합한 상황** |
|--------------------------|--------------------------|
| ✅ 명확한 "is-a" 관계일 때 | ✅ "has-a" 관계가 더 적절할 때 |
| ✅ 공통 인터페이스가 필요할 때 | ✅ 런타임에 동작을 변경해야 할 때 |
| ✅ 템플릿 메서드 패턴이 필요할 때 | ✅ 여러 클래스의 기능을 조합해야 할 때 |
| ✅ 다형성이 핵심일 때 | ✅ 상속 계층이 복잡해질 때 |

---

## 🎯 핵심 원칙

### 🔍 언제 리팩토링할까?

1. **🚨 코드 냄새가 날 때**
   - 중복 코드, 긴 함수, 큰 클래스
   - 복잡한 조건문, 데이터 클래스

2. **🔧 기능 추가 전에**
   - 새 기능을 추가하기 쉽게 구조 개선
   - 코드 이해도 향상

3. **🐛 버그 수정할 때**
   - 버그의 원인이 되는 구조적 문제 해결
   - 유사한 버그 방지

### 🎯 리팩토링 단계

1. **🧪 테스트 코드 작성**
2. **🔄 작은 단위로 변경**
3. **✅ 테스트 실행**
4. **🔄 반복**

> 💡 **기억하세요**: 리팩토링은 기능 변경 없이 코드 구조만 개선하는 것입니다!
