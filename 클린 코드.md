## 1. 기이한 이름
체력을 나타내고자 할 때. <br><br>
나쁜 예시 : int baldamsaka; <br>
좋은 예시 : int Hp; <br><br>

어떤 역할을 할 것 같은 예측이 가능해야 한다.
<br><br>
## 2. 중복 코드
void NotBossMonsterDamage();<br>
void BossDamage();<br>
void BigBossDamage();<br><br>

비슷한 역할의 코드가 중복되어 있다.<br><br>

void Damage();<br><br>

하나의 역할로 줄인 다음 내부에서 처리를 다르게 하자. <br><br>

## 3. 긴 함수 
void ALL_IN_ONE()<br>
{<br>
  // 밑으로 2000천 줄 있음. <br> 
}<br>

여러 기능을 한꺼번에 다 담으면 코드 변경이 힘들다.<br>
<br>
void Move();<br>
void Look();<br>
void run(); <br>
<br>
함수를 쪼개자.<br>
<br>
## 4. 긴 매개변수 목록<br>
void InitWeapon(FString Name, float Damage, float FireRate, int32 AmmoCount, float ReloadTime, USkeletalMesh* Mesh, USoundBase* Sound)
<br> 
저 많은 매개 변수를 어쩌라는 건가... <br>
<br>
void InitWeapon(struct Data) <br>
하나의 구조체로 묶어서 변수를 넣게 하던가.<br>
<br>
void InitWeapon(a,b,c) 변수를 줄이자. <br>
<br>
## 5. 전역 변수의 남용<br>
모든 걸 전역 변수로 하면? 누구나 접근해서 수정이 가능하다.<br>
되도록 전역 변수는 줄이자.<br>
<br>
## 6. 가변 데이터<br>
누구나 접근해서 바꿀 수 있거나 특정 로직이 아니여도 접근이 가능하다면? <br>
누구나 수정이 가능하기에 값이 자주 바뀌어 예기치 못한 오류나 복잡도가 증가한다. <br>
접근과 변경 가능한 범위를 최소화하자. <br>
<br>
## 7. 뒤엉킨 변경<br>
데이터, 게임 플레이 관련 클래스를 하나로 묶으면? <br>
하나라도 변경해야 할 경우, 실수로 다른 것을 건드릴 수 있음. <br>
클래스는 하나의 목적만 가지게 하자. <br>
<br>
## 8. 샷건 수술<br>
캐릭터 클래스 - 데미지 로직 있음 <br>
몬스터 클래스 - 데미지 로직 있음 <br>
무기 아이템 클래스 - 데미지 로직 있음 <br>
<br>
이렇게 여러 군데로 나누면 데미지 계산 변경할 때 너무 어려워진다.
<br>
데미지 계산 클래스 - 여기서 전부 계산 담당 <br>
<br>
이렇게 바꾸자.<br>
<br>
## 9. 기능 편애<br>
캐릭터 이동 로직 클래스 - 캐릭터 매번 참조 <br>
캐릭터 클래스 - 내부적으로 이동 로직 없음 <br>
<br>
만약 캐릭터 이동 로직이 샷건 수술이 필요할 정도로 다양하게 쓰이지 않는다면<br>
이 경우에는 이동 로직을 캐릭터 내부에 넣는 것이 클래스 수를 줄일 수 있으며 <br>
추후 데이터 관리도 편하다.<br>
<br>
## 10. 데이터 뭉치<br>
float, int, int, int, double....<br>
이렇게 모아놓으면 너무 불편하다. <br>
<br>
구조체를 만들어서 관리하자.<br>
<br>
## 11. 기본형 집착<br>
만약에 Health 에 여러 로직이 필요하다면?<br>
int MaHealth, int MyHealth, int LastHealth, int MinHealth....<br>
<br>
이러면 데이터 변수가 늘어나서 관리하기 힘들다.
<br>
class Health 이렇게 묶든가 해서 안에 로직을 나누자.<br>

## 12. 반복되는 스위치문<br>
스위치문을 여러 개 쓸 바에 다형성을 활용하자.<br>


## 13. 반복문<br>
반복문은 게임 성능을 떨어뜨린다. 최소화하자. <br>

## 14. 성의 없는 요소<br>
하늘 일 없이 존재하거나 중계만 해주거나 아주 가끔 등장하는 메서드, 클래스...<br>
이거 굳이 필요없으면 다른 클래스에 합치자. <br>
클래스가 적은 만큼 보기 편해진다.<br>

## 15. 추측성 일반화<br>
인벤토리 시스템 만들 때 엄청나게 크게 만들어야지! <br>
근데 그게 언제 쓰일 줄 알고?<br>
일단 현재에 집중 <br>
추후 확장해도 늦지 않음<br>

## 16. 임시 필드<br>
같은 공격이라도 근거리 공격, 원거리 공격이 있을 때<br>
둘을 합쳐놓았는데 하나는 안 쓴다?<br>
그럼 차라리 둘을 쪼개서 넣자.<br>

## 17. 메시지 체인<br>
길게 이어진 참조는 하나라도 무너지면 연쇄고리로 와장창!<br>
참조는 가능하게 짧게<br>

## 18. 중재자<br>
중간다리 연결 클래스? <br> 유통이 많으면 가격이 왜 오를까? 중간에서 헤처멱으니까!<br>
코드도 똑같다. 중간에서 헤처먹으면 비용이 더 든다.<br>
되도록 직거래를 유도하자.<br>

## 19. 내부자 거래<br>
캐릭터랑 클래스랑 서로 데이터를 막 참조하고, 알아서 지들끼리 쿵짝한 다음 UI도 갱신?<br>
하나라도 삐끗하는 순간 디버깅 지옥에 빠진다.<br>
되도록 거래는 한번에 하나씩 이루어지게 처리하자<br>

## 20. 거대한 클래스<br>
퀘스트, 아이템, 스토리, 캐릭터, 몬스터, 전부 관리하는 클래스????<br>
엄청 거대하거나 복잡한 클래스는 삐끗하면 디버깅 지옥이 된다.<br>
일정 규모 이상의 클래스는 나누자.<br>

## 21. 서로 다른 인터페이스의 대안 클래스<br>
클래스를 교체하려면 인터페이스가 호환되어야 한다.<br>
따라서 규격이 되는 인터페이스 클래스를 만든 다음<br>
그 클래스에서 뻗어나가자.<br>


## 22. 데이터 클래스<br>
굳이 setter, getter 를 만들지 말자. <br>
내부에서 처리 가능하면 처리 가능하게 하자.<br>


## 23. 상속 포기<br>
필요하지 않은 부분은 굳이 상속하지 말자.<br>

## 24. 주석의 남용<br>
주석을 500개 쓰면 그거 읽느라고 코드 못봄.<br>
